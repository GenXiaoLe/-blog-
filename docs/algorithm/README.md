## 目录

1. 前言
2. 数据结构-数组
3. 数据结构-字符串
4. 数据结构-链表
5. 数据结构-栈
6. 数据结构-队列
7. 数据结构-二叉树(待更新)
8. 数据结构-堆(待更新)
9. 算法思想-DFS与BFS
10. 算法思想-递归与回溯(剪枝)思想
11. 算法思想-好用到爆的套路之动态规划(待更新)

## 前言

小葵花妈妈课堂开课咯！

数据结构对于我们来讲是很重要的一环，掌握数据结构以及使用也是作为程序员的必须要求，对于提升编程能力和代码质量有很大的作用。

同时，随着数据结构的深入学习，我们绕不开的一环就是被称为编程中的修仙玄学：**算法**。

我们这里主要以干货为主，也不整虚头巴脑的了，直接就从数据结构入手，在认识数据结构的同时，逐步进行基础的算法学习。

奥利给，干就完了！

## 数据结构-数组

> 万里长征第一步，咱们就从数组入手。数组是我们最经常接触的数据结构的一种，不管是栈还是队列的使用，都能在数组中体现，这些会在后续中介绍，我们先把数组当成开胃菜，简单地搞搞。

对于数组就不花费时间来介绍了，都是老熟人了。直接就上题目！

### 强大的指针

说起数据结构与算法，指针法可是业界公认的解题好手，我们这里先简单的认识一下指针，后续再做更多的应用！

指针的主要作用是标记作用，用来标记某个结点，也被称作游标，最常用的是双指针法，对于复杂的问题也有多指针解法。

双指针的用处很多，常用的有快慢指针法和对撞指针法。比如vue2中的diff算法，使用的是两对双指针对撞指针的算法。下面我们来做几道题感受一下指针的用处！

**合并两个有序数组**

> 题目：给定两个数组，两个数组合并成一个有序数组

> 示例：  
> 输入: [1, 2, 3, 5]，[2, 4, 6]
> 输出: [1, 2, 2, 3, 4, 5, 6]

我们现在有两个数组[1, 2, 3, 5]，[2, 4, 6]，我们要把两个数组合并成一个有序数组[1, 2, 2, 3, 4, 5, 6]。也不绕弯了，这道题标准解法就是双指针法，也是双指针法的基础用法。

这里我们稍缓节奏，先缕一下思路：

1.先对每个数组分别定义一个指针，指向数组的索引值0位。并声明一个空数组

2.如果第一个指针的数字小于第二个指针的数字，则把第一个指针的数字push到空数组中，指针向前走一位。否则push第二个指针的数字，第二个指针向前走一位。如果相等，则都push进去，两个指针均向前一位。

3.如果有一个数组已经先遍历完，另一个数组还有剩余，则直接push到数组最后面

好了，思路有了，我们来实现代码

```js
const merge = function(nums1, nums2) {
  	let arr = []
    let i = 0
    let j = 0
    // 当两个数组都没遍历完时，指针同步移动
    while(i < nums1.length && j < nums2.length) {
        if (nums1[i] < nums2[j]) {
          arr.push(nums1[i])
          i++
        } else if (nums1[i] > nums2[j]) {
          arr.push(nums2[j])
          j++
        } else {
          arr.push(nums1[i])
          arr.push(nums2[j])
          i++
          j++
        }
    }
    
    // nums2或者nums1 留下的情况，特殊处理一下 这里就不写了
};
```

**三数求和问题**

认识了指针法之后，我们来一道数组经典中的经典题，三数求和问题，即给定一个数组，给定一个固定值，求数组中哪三个数相加能够得到我们的固定值。这道题刚入手相信大家的解法都是层层遍历嵌套，来寻找集合，但是我们使用双指针的对撞指针解法能够轻松而又优雅的解决。

刚开始讲究循序渐进，老规矩还是先理一下解题思路。

1.我们可以对数组进行排序，转化为有序数组

2.固定一个数字，然后在头尾各设置一个指针，三个数相加看是否符合规定。

3.如果三数之和比固定值大，说明右侧的数偏大了，右指针左移。

4.如果三数之和比固定值小，说明左侧的数偏小了，左指针右移。

```js
const threeSum = function(nums, count) {
    // 用于存放结果数组
    let res = [] 
    // 给 nums 排序
    nums = nums.sort((a,b)=>{
        return a-b
    })
    // 缓存数组长度
    const len = nums.length
    // 注意我们遍历到倒数第三个数就足够了，因为左右指针会遍历后面两个数
    for(let i=0;i<len-2;i++) {
        // 左指针 j
        let j=i+1 
        // 右指针k
        let k=len-1   
        // 如果遇到重复的数字，则跳过
        if(i>0&&nums[i]===nums[i-1]) {
            continue
        }
        while(j<k) {
            // 三数之和小于count，左指针前进
            if(nums[i]+nums[j]+nums[k]<count){
                j++
               // 处理左指针元素重复的情况
               while(j<k&&nums[j]===nums[j-1]) {
                    j++
                }
            } else if(nums[i]+nums[j]+nums[k]>count){
                // 三数之和大于count，右指针后退
                k--
               
               // 处理右指针元素重复的情况
               while(j<k&&nums[k]===nums[k+1]) {
                    k--
                }
            } else {
                // 得到目标数字组合，推入结果数组
                res.push([nums[i],nums[j],nums[k]])
                
                // 左右指针一起前进
                j++  
                k--
               
                // 若左指针元素重复，跳过
                while(j<k&&nums[j]===nums[j-1]) {
                    j++
                }  
               
               // 若右指针元素重复，跳过
               while(j<k&&nums[k]===nums[k+1]) {
                    k--
                }
            }
        }
    }
    
    // 返回结果数组
    return res
}
```

在上面这道题中，左右指针一起从两边往中间位置相互迫近，这样的特殊双指针形态，被称为“对撞指针”。那么数组什么时候可以使用对撞指针呢？我们需要注意一个关键词：**有序**。

好了，数组就先介绍到这里。之后在栈和队列中有更加深入的介绍。

## 数据结构-字符串

> 字符串作为基础数据类型，相信也不用多说了，并且字符串重点难点更多在于隐式转换以及正则部分，算法涉及到的相对较少，这里也仅仅做一个而简单的介绍，用来抛砖引玉。

### 指针的妙用

**字符串反转**

这个属于基础类型，相信大家都是信手捏来

> 题目：给定一个字符串，输出反转后的字符串

> 示例：  
> 输入:'abcdefg' 
> 输出:'gfedcba'

 

```js
// 定义被反转的字符串 
const str = 'abcdefg'  
// 定义反转后的字符串
const res = str.split('').reverse().join('')
```

**回文判断**

回文判断是字符串考题中的常见题型，衍生题型也很多，我们这里用几个例子来举例。

回文字符串，就是正着读和倒着读都一样的字符串，这道题解法有很多，比如我们上面的反转字符串解法就能解决，也可以利用双指针对撞的方式，或者利用回文字符串的对称性从中间劈开判断两边的字符是否相等，都是非常好用的方法，我们选择一种方法来实现。

```js
// 双指针判断
function isPalindrome(str) {
  // 缓存字符串的长度
  const len = s.length

  // i、j分别为左右指针
  let i = 0, j = len - 1
  
  while(i < j) {
    // 如果左右指针指向的字符不同，则不是回文，否则两个指针向中间靠拢
   	if(str[i] !== str[j]) {
        return false
    }
    i++
    j--
  }
  return true
}

// 利用回文对称性特性
function isPalindrome(str) {
    // 缓存字符串的长度
    const len = str.length
    // 遍历前半部分，判断和后半部分是否对称
    for(let i=0;i<len/2;i++) {
        if(str[i]!==str[len-i-1]) {
            return false
        }
    }
    return true
}
```

**回文判断衍生题**

下面我们来一道回文判断的衍生题。

给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

```js
// 例子：
abboa // true 删掉o 字符串变为回文
abbona // false
```

其实看完上一道题的解法，我们应该对这道题有了基本的思路，真相只有一个(bushi)，还是利用双指针，只不过要做一丢丢改造。如果碰到不是回文的情况，给他一个机会，左指针或者右指针移动一次，看是否能够维持回文的对称特性。

```js
const validPalindrome = function(s) {
    // 缓存字符串的长度
    const len = s.length

    // i、j分别为左右指针
    let i=0, j=len-1
    
    // 当左右指针均满足对称时，一起向中间前进
    while(i<j&&s[i]===s[j]) {
        i++ 
        j--
    }
    
    // 尝试判断跳过左指针元素后字符串是否回文
    if(isPalindrome(i+1,j)) {
      return true
    }
    // 尝试判断跳过右指针元素后字符串是否回文
    if(isPalindrome(i,j-1)) {
    	return true
    }
    
    // 工具方法，用于判断字符串是否回文
    function isPalindrome(st, ed) {
        while(st<ed) {
            if(s[st] !== s[ed]) {
                return false
            }
            st++
            ed--
        } 
        return true
    }
    
    // 默认返回 false
    return false 
};
```

好了，数组和字符串就暂时介绍到这里了，对于指针我们也有了基本的认识和概念。开胃菜已经差不多了，下面我们开始进入正题，去探究一下数据结构预算法的魅力所在！

## 数据结构-链表

> 链表在数据结构中是非常重要的一个点，因为他每个节点都是按顺序链接，排列，就像一根链子连起来的一样，因此具有很强的前后关联性。可以通过简单地循环轻松进行节点的增删改查操作，是性能非常高的一种数据结构

### 链表的表现形式

```js
let head = {
  val: 1,
  next: {
    val: 2,
    next: {
      val: 3,
      next: null
    }
  }
}
```

### 来一个链表生成的简易方法

```js
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val)
  this.next = (next === undefined ? null : next)
}
```

### 链表的基础使用

> 上面介绍了链表进行了基础介绍，也展示了链表的表现形式以及生成方法，相信大家对于链表已经有了一丢丢的了解，下面我们通过一些实战来看一下链表到底怎么玩

1. 双链表合并

最开始我们先来一个开胃菜。现在假设我们有两个链表`1->5->7->9`和`2->3->6->8`，那我们怎么把两个链表按顺序整合在一起，组成一个按顺序排列的新链表呢？大家可以先想一下解决方案。

如果是数组结构，两个数组我们至少要进行两次循环遍历才能解决问题。但是对于链表结构而言，只需要一次遍历！大家对于链表结构的优秀性能是否有了一些认识呢，下面我们来实操一波。

先整理一下思路，我们要将两个链表按顺序整合，如果把链表的节点想象成一个个的扣子，那么我们需要一根**线**来把他们按顺序穿起来，我们现在需要做的就是创造这样的一根**线**。

```js
function mergeTwoLists(left, right) {
  let head = new ListNode()
  let cur = head
  
  // 循环遍历知道left或者right结束为止
  while (!left || !right) {
    if (left.val > right.val) {
      // 如果是左侧的大 则先把右侧的“穿进去”
      cur.next = right
      // 右侧推进一步
      right = right.next
    } else {
      // 反之把左侧的“穿进去”
      cur.next = left
      // 左侧推进一步
      left = left.next
    }
    
    // “线”推进一步
    cur = cur.next
  }
  
  // 如果结束后left或right还有没遍历到的，则拼到最后
  cur.next = left !== null ? left : right
  
  return cur.next
}
```

2. 链表节点的删除

上面的例子展示了链表结构的高性能。但是呢，对于他的特点，表现得还不是特别明显，那么我们再通过一个例子来展示一下链表相较于其他结构特殊的地方，也就是节点的特性。

我们现在有一个这样的链表`1->2->2->3->3->4->5->6`，我们要把重复的节点2，3删掉，最后新的链表为`1->2->3->4->5->6`。

对于数组而言，抛开es6提供的去重方法等，常规解决方法是新建一个空数组，对原数组进行遍历，如果没有找到push，找到则继续遍历。

那么对于链表而言我们只需要判断当前节点和下一个节点是否重复，如果重复则直接删除下一个节点，不重复继续，那么如何删除呢？我们只需要把当前节点和下下个节点连接就ok了，重复节点会被直接干掉。

```js
function deleteNodeList (head) {
  let cur = head
  
  while(cur.next) {
    if (cur.val === cur.next.val) {
      // 如果重复，则干掉下一个重复的节点
      cur.next = cur.next.next
    } else {
      // 否则，推进链表继续遍历
      cur = cur.next
    }
  }
  
  return head
}
```

这个例子我们展示了链表的一个特性，即节点之间的强关联性，每个节点之间都是相关的，从本质上我们只需要建立节点之间的联系，就能完成一系列的操作。这个问题其实看起来很简单，只有几行代码，是一道很经典的基础数据结构题。虽然只是利用了链表的基础特性，但是在我接触的人中，对于这道题目没思路的，写不完整的，写完跑不起来的大有人在，还是希望大家可以去多多思考、理解链表结构的本质。

3. 链表节点的删除问题的拓展(dummy节点登场)

下面我们把这个节点的删除问题延伸一下，上面的是我们只删除重复节点，那么下面我们加一点点难度，只要有重复的，就把重复节点全部删掉。

我们现在有一个这样的链表`1->2->2->3->3->4->5->6`，因为2，3节点有重复，我们把重复的节点2，3全部删掉，最后新的链表为`1->4->5->6`。

对于数组的而言(数组：请打开麦克风交流，为什么针对我？)，这个操作就就很烦，因为数组前后的值缺乏关联性，还需要在查到有重复值时候，反复遍历新数组，把重复的值干掉。无论怎么优化复杂度至少n2，一个写不好甚至还要往上。

但是对于链表的话，这个问题就是so easy，我们只需要利用链表的节点关联特性，对上面的方法做一点点的优化。下面我们要引入一个处理链表的常用概念`dummy`节点。

**dummy节点是什么**：

​	其实说白了就是一个首节点游标是空的链表。因为链表的特殊结构，他必须有一个起点，如果把起点干掉了，这个链表也会抛错。那么为了让原链表头部可以被删除，我们需要创建一个起点为空的链表来承接原链表，这就是dummy节点，下面我们用代码来直观的看一下。

```js
let head = {
  val: 1,
  next: {
    val: 2,
    next: null
  }
}

let dummy = {
  val: null,
  next: head
}
```

那么既然有了dummy节点，我们就来解决一下上面这个问题

```js
function deleteDuplicates (head) {
  let dummy = new ListNode()
  dummy.next = head
  
  let cur = dummy
  
  // 下个节点和下下各节点都存在的时候
  // 注：这么写是因为dummy起点为空哦
  while(cur.next && cur.next.next) {
    if (cur.next.val == cur.next.next.val) {
      // 对 cur 后面的两个结点进行比较 如果相同
      let val = cur.next.val
      // 将所有相同节点全部干掉，反复地排查后面的元素是否存在多次重复该值的情况
      while(cur.next && cur.next.val == val) {
        cur.next = cur.next.next
      }
    } else {
      // 两个节点不同则直接推进到下一个节点
      cur = cur.next
    }
  }
  
  return dummy.next
}
```

我们通过两个例子认识了下链表的基础特性，对于简单链表也有了基本的操作能力。那么下面咱们就升级一下难度，来点有意思的，玩一玩复杂链表和环形链表，下面的内容可能有些难度，涉及到了指针(游标)、多指针、快慢指针、Map标记链表等知识，还是希望大家多花时间琢磨一下。

### 复杂链表的使用

上面我们通过几个例子，简单地认识了链表的特性和使用，因为上面的例子中的链表结构都是有序的，处理的时候省了很多事情。但是对于大多的链表结构往往是没有特定规律，那么我们怎么去处理这些链表呢？下面我们引入**指针(游标)**的概念。

指针简单地来说起到的是标记链表位置的作用，也可以称作游标，在上面的数组介绍中，我们已经使用过指针了，下面我们利用指针来处理一下链表问题。

1. **双指针法**

> 双指针通常的用法是，快慢指针以及对撞指针，我们的例子中均会有涉及到，这里我们先用快慢指针来处理一个简单问题

**删除某个区间的节点：**

我们现在有一个链表`1->5->4->8->10->3->7`，我们现在要做的是需要删除某个区间的所有节点。这个功能对于数组很简单，对于链表直接遍历也可以处理，没什么难度。但是我们既然要玩儿花的，就用快慢指针来解决问题，当然这个有点杀鸡用牛刀，反而增加了复杂度，不过也是先体验一把。

思路也很简单，我们知道区间是m, n，先设定一个快指针，先行n步，然后快慢指针同时前进，当慢指针前进到m步的时候，要删除的区间就出来了，我们直接干掉快慢指针中间的区域就ok，下面实现一波

```js
function removeNthFromEnd (head, m, n) {
  // 引入dummy节点
  let dummy = new ListNode()
  dummy.next = head
	
  // 设定快慢指针，指向dummy节点起始处
  let fast = dummy
  let slow = dummy

  // 快指针先行 和慢指针隔开n个位置
  while(n !== 0) {
    fast = fast.next
    n--
  }
	
  // 快慢指针同时走
  while (m !== 0) {
    fast = fast.next
    slow = slow.next
    m--
  }

  // 走完之后 慢指针已经停在了要删除的其实节点 连接快指针 干掉相应区间的节点
  slow.next = fast.next

  return dummy.next
}
```

看完这个例子有没有觉得指针很好玩呢？下面我们来搞一点有难度的。

2. **多指针法**

> 顾名思义，多指针是存在多个指针，一般用来标记各个不同的点和位置，记录相应的状态，从而实现功能

下面我们要通过几个例子来感受一下链表中的【链】的本质。链表为何称之为链表，在我的理解看来，他就是一个**链子**，每个结点都连接着后续的所有结点，无论从某任意结点处断开，或者改变指针方向，都会形成新的链表。所以呢，**处理链表的本质，是处理链表结点之间的指针关系**。敲黑板哦！！！这个可是重点，链表的关键点全在这里。

**全量反转颠倒链表(理解链表基础重点题目，要划重点哦！！！)**

现在我们有一个链表1->2->3->4->5，我们要通过一个方法实现链表的完全反转，转化为5->4->3->2->1。

因为链表无法直接从尾->头，所以最直接的办法是我们在头->尾的过程中不断地将当前节点的后续节点变为当前节点的前驱结点，即由1->2, 变为2->1。

透过问题看本质，结合我们上面说的，其实就是把所有指针全部换一个方向就OK，把1->2->3->4->5->null变为null<-1<-2<-3<-4<-5，对比着看是不是有点意思了呢？下面我们来使用**多指针法**操作cur(目标节点)，pre(目标节点的前驱节点)，next(目标节点的后续节点)这三个节点来实现一下。

```js
function reverseList (head) {
  // 设定前驱节点为pre，第一次为null
  let pre = null
  // 目标节点为链表的第一个节点
  let cur = head
	
  // 当没走到最后的时候继续循环
  while(cur != null) {
    // 先记录下当前结点所有后续节点
    let next = cur.next
    // 反转指针：把当前结点的指针指向前驱结点，实现相邻接点指针反转
    cur.next = pre
    // 前驱结点变为目标结点，前驱结点相当于往前走一步
    pre = cur
    // 由于指针反转之后，链表断开为两个链表，为了目标结点能继续走下去，需要把当前结点的指针指向后续结点，目标节点相当于也往前走一步
    cur = next
  }
  
  // 返回反转之后的链表
  return pre
}
```

这个例子看完是不是完全懵了呢...什么改变指针方向....什么前驱后续的....其实这里不理解也肯正常，反转链表是个宝库，集成了链表大多的精华部分，吃透这道题，链表这个数据结构就掌握一半了！！！真心建议大家这个题反复的去看，去细品，一定会有很大收获！！！

**局部反转链表**

虽然反转链表有点难，但是咱们还是要成热打铁，结合前面学到的知识，再给反转链表加一丢丢的难度。

下面我们来实现一个局部的反转链表，即1->2->3->4->5->6->7，转化为1->2->6->5->4->3->7。只反转一定范围内链表结构。

这个怎么做呢，这个题咋一看这个有点难，但是我还是希望同学们看到这个题能有点点思路。

其实翻翻上面提到的，无非不过是快慢双指针确定范围，再来一个范围内的全量反转链表。害，说了半天，不就是个缝合怪吗？

那么咱们下面就来治治他！

```js
function reverseBetween (head, m, n) {
  // 定义前驱结点，目标结点
  let pre, cur, leftHead
	
  // 来一个dummy结点，避免第一个结点处理不到
  const dummy = new ListNode()
  dummy.next = head

  // p相当于一个指针，指向链表的位置
  let p = dummy

  // 先走到要反转的链表起始位置
  for (let i = 0; i < m - 1; i++) {
    p = p.next
  }

  // 记录左边缘的全部结点
  leftHead = p

  // 开始反转的第一个节点
  let start = leftHead.next

  // 前驱节点
  pre = start

  // 当前节点
  cur = pre.next

  // 老规矩，开始在指定范围全量反转
  for (let i = m; i < n; i++) {
    let next = cur.next
    cur.next = pre
    pre = cur
    cur = next
  }

  // 将反转后的链表拼接左边缘结点
  leftHead.next = pre

  // 将区间反转后start也成为了最后一个结点，然后和cur之后未反转的结点连接
  start.next = cur

  return dummy.next
}
```

其实u1s1，这个题的意义远不如上面的一道，不过也算是一个复杂链表理解的一个强化训练吧，就不多解释啦。

**环形链表**

既然讲链表，那么下面咱们来解锁一个特殊姿势的链表：**环形链表**。

上面是环形链表呢？顾名思义，就是环形的链表，一般的链表像蛇一样，是一条线。而环形链表像贪吃蛇咬到自己的尾巴，变成了一个环，头就是尾，尾也是头。

说不如练，咱们先来理解一下环形链表，做道小题，判断一个链表是否为环形链表。

**判断链表是否为环形链表**

1.flag法

这个思路也很简单，一直往前走，走了重复的路，就代表是环形链表了呗。所以最简单的办法只需要在节点上面打一个flag，如果是环形链表，总能再次见到他。

```js
function startCycleFlag (head) {
  let cur = head

  while (cur.next) {
    cur.flag = true
    cur = cur.next
    if (cur.flag) {
      return `this head is cycle，this start is ${cur.val}`
    }
  }

  return 'this head is not cycle'
}
```

2.升级版flag法

由于直接在链表上打flag会造成数据污染，虽然只是简单的题目，我们也要尽量很优雅的解决。

这里我们引入Map对象，每走一步都把目标结点存入Map中，如果存入之前在Map中找到了重复结点，则证明是环形链表。

```js
function startCycleMap (head) {
  const cycleMap = new Map()
  let cur = head
  let index = 1
  while (cur.next) {
    if (cycleMap.has(cur)) {
      return cur
    } else {
      cycleMap.set(cur, index)
      cur = cur.next
      i++
    }
  }
}
```



3.快慢双指针法

这个是设置两个指针，一快一慢，只要是环形链表，快指针一定能够追上慢指针。

```js
function isCycle (head) {
  let fast = head
  let slow = head

  while (fast && fast.next) {
    // 快指针走两步 慢指针走一步
    fast = fast.next.next
    slow = slow.next

    // 如果相等则证明是环形链表
    if (fast.val === slow.val) {
      return slow
    }
  }
  return false
}
```

**定位环形链表的起始位置**

环形链表的常见衍生题目就是寻找环形链表的起始位置，刚才的flag法可以简单暴力的解决我们的问题。但是，我们既然要学习，还是要多玩点花样，那么就用业界公认的快慢指针法来解决这个问题。

快慢指针虽然可以判断链表是否为环形链表，但是却无法精确的判断起始位置。所以我们要利用下快慢指针的精髓！

1.找出环形链表的长度N，让快指针先走N步，以保证他们的间隔是整个环形链表的长度。

2.快慢指针同时往前走，当快慢指针重合时候，即头尾重合，也就是环形链表的起点！

```js
// 判断是否是环形链表
function isCycle (head) {
  let fast = head
  let slow = head

  while (fast && fast.next) {
    // 快指针走两步 慢指针走一步
    fast = fast.next.next
    slow = slow.next

    // 如果相等则证明是环形链表
    if (fast.val === slow.val) {
      return slow
    }
  }
  return false
}


function startCycle (head) {
  let cycle = isCycle(head)

  if (!cycle) {
    return 'this head is not cycle'
  }
	
  // 是环形链表 且此时快慢指针已经处在环形链表中了
  // 计算环形链表的长度
  let count = 1
  let fast = cycle
  let slow = cycle.next
	
  // 慢指针走，计算链表长度
  while (slow.val !== fast.val) {
    slow = slow.next
    count++
  }

  // 重置快慢指针的位置
  fast = head
  slow = head

  // 让快指针先行count步 保证他们间隔是一个环形链表的长度
  while(count > 0) {
    fast = fast.next
    count--
  }

  // 快慢指针同时进行
  while(fast.val !== slow.val) {
    fast = fast.next
    slow = slow.next
    // 相遇时，即为头尾重合的时候，也就是环形链表的起点
    if (fast.val === slow.val) {
      return `this start is ${fast.val}`
    }
  }
}
```



环形链表属于特殊的链表结构，也不需要过多纠结，能够通过上面的题目理解即可。但是常用链表结构还是需要多花一些掌握的。React中Diff的Fiber结构也是用链表来重写的，链表结构的优秀性能可见一斑。

那么链表差不多就介绍到这里了，我们开始下一趴！

## 数据结构-栈

**队列**和**栈**这两个兄弟比较微妙。因为这两者与其说是数据结构，不如说更像是一种处理数据的概念。并且我们在解决问题的时候，往往不会看到队列或者栈的关键字，但是他切切实实存在在诸多场景中。本节我们旨在学习栈的结构，队列放在后面再来说。

### 栈的概念

栈对于我们来讲并不陌生，经常接触的除了队列和栈，还有堆栈的概念。但是不管哪种，栈始终遵循的一个原则就是【先进后出】，即**先被压入栈的必然在最后出栈**。举个例子就好像我们吃黄桃罐头，最下面的必然是最先装进去的，但往往我们最后才能吃到。罐头瓶和栈一样是一个单向进出的结构，这个也是栈结构的常识，要和队列区分开。

### 简易的栈方法

```js
class stack {
  constructor () {
    this.result = []
  }

  pop () {
    return this.result.pop()
  }

  push (item) {
    this.result.push(item)
  }
  
  get () {
    return this.result
  }
}
```



### 初识栈结构

知道了什么是栈，我们来一个常见的场景来熟悉一下栈的使用。在我们进行自定义计算式是否有效的校验中，需要校验的一项是括号的使用是否正确，即括号是否成对出现。

```js
// "()" => true
// ")(" => false

// 复杂一点
// "[()]" => false
// "([)]" => false

```

这类校验怎么做呢？我们可以想一下，括号组意味着对称性，即如果有括号的后半部分，必然需要有对应的前半部分。通过我们上面的事例可以看出，如果是有效的括号组，遍历时遇到第一个右括号时，他的**前一个值**必然是他对应的左括号！而栈结构具有先进后出的特性，刚好可以在遇到后半部分的时候，查看一下栈顶的括号是否是他的前半部分，那下面我们就开始实现一下！

```js
// 维护左括号和右括号的对应关系
const leftToRight = {
  "(": ")",
  "[": "]",
  "{": "}"
}

const isValid = function(s) {
  // 空字符串无条件判断为 true
  if (!s) {
    return true;
  }
  // 初始化栈数组
  const stack = [];
  // 缓存字符串长度
  const len = s.length;
  // 遍历字符串
  for (let i = 0; i < len; i++) {
    // 缓存单个字符
    const ch = s[i];
    
    if (ch === "(" || ch === "{" || ch === "[") {
      // 判断是否是左括号，如果是左括号，把匹配的右括号存入
      stack.push(leftToRight[ch]);
    } else {
     	// 若不是左括号，则必须是和栈顶的左括号相配对的右括号
      // 若栈不为空，且栈顶的左括号没有和当前字符匹配上，那么判为无效
      if (!stack.length || stack.pop() !== ch) {
        return false;
      }
    }
  }
  // 若所有的括号都能配对成功，那么最后栈应该是空的
  return !stack.length;
};
```

这个属于栈的基础应用，只是简单地认识一下栈结构，下面我们通过一道例题来深入了解一下栈结构。

### 栈问题的进阶

我们现在做一道真题。【根据每日气温列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。】

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

这道题最容易理解的是直接用双层遍历来暴力解决，第一层定位一个温度，第二层遍历来确定升温天数的index值，两个索引值相减得出间隔几天升温。

但是，暴力解法往往是在我们没有好的方法时候使用，因为他的性能必然有相当大的缺陷。那么我们有更好的解法吗？答案是，当然有！

我们可以审一下题，题目其实说升温，那么我们可以在遍历数组的时候先创建维持一个递减的数组，当有一个温度升高，打破了我们递减数组的平衡，那么我们需要找出数组中这个温度的**前一个值**，来计算两个值的索引差...等等！我刚才是不是说了前一个值，那么结合上一题，我们应该想到用栈的方法来解决这个题了。

确定了方法之后，我们重新整理一下思路，我们可以在第一次遍历数组的时候，把所有元素的索引值依次入栈，维持一个递减的数组，如果一旦有元素打破了递减趋势，那么我们需要依次取出栈顶的索引值，计算出和当前索引值之差(升温天数)，直到栈清空或者继续维持递减趋势。记录升温天数的数组，就是我们要的最终答案！

```js
function dailyTemperatures (T) {
  // 初始化数组的长度
  const len = T.length
  
  // 初始化一个栈
  const stack = []
  
  // 初始化结果数组，注意数组定长，占位为0
  const res = (new Array(len)).fill(0) 
  
  // 开始第一次遍历
  for (let i = 0; i < len; i++) {
    // 如果栈的长度不为0，且不能维持递减数组的时候
    const lastIndex = stack.length - 1
    while (stack.lengt > 0 && T[i] > T[stack[lastIndex]]) {
      // 将栈顶的元素取出
      const top = stack.pop()
      
      // 计算二者之间的索引差差值
      res[top] = i - top
    }
    
    // 将当前索引值存入栈中
    stack.push(i)
  }
  
  return res
}
```

从上面的解法可以看出，比起暴力双层循环解法，我们在使用栈结构解决这个问题的时候，已经参与过对比的数字，不会被重复被对比，也就是说其实我们只把原数组遍历了一次，对于数组来讲我们的时间复杂度已经从 O(n^2)降到了O(n)，不得不说栈结构真的是个好东西啊！

## 数据结构-队列

### 队列的概念

在认识了栈之后，我们可以来学习认识一下队列结构。队列顾名思义，就是把所有数据排队，按照【先进先出】的原则来进行出队入队。如果说栈结构是单方向进出，队列则是双向进出，这个特性要和栈结构区分开来。并且我们从队列多入口和多出口的特性，也可以预料到，队列能实现更加复杂的数据操作。

### 简易的队列方法

```js
class queue {
  constructor () {
    this.result = []
  }

  pop () {
    return this.result.pop()
  }

  push (item) {
    this.result.push(item)
  }
  
  peek () {
    return this.result.length
  }
  
  empty () {
    return !this.result.length
  }
}
```



### 初识队列结构

我们先来转换到队列的思想，先做一道小题开阔思路。如何把一个栈结构转变为队列结构呢？我们先来理一下思路。

1. 栈是先进后出，而队列是先进先出，可以看出来队列算是栈的逆序操作
2. 说到逆序，那我们可以建立两个栈，把初始栈内的数据依次出栈存入到新的栈内，形成完全倒序栈，再依次从新的栈出栈即可
3. 但是有一种情况，是我们在新的栈未完全清空栈内数据的情况下，旧的栈又有了新的数据，这时我们可以在旧的栈数据全部出栈之后，在进行第二步，这样就能保证始终倒序的顺序。

```js
const MyQueue = function () {
  // 初始化两个栈
  this.stack1 = [];
  this.stack2 = [];
};

MyQueue.prototype.push = function (x) {
  // 直接调度数组的 push 方法
  this.stack1.push(x);
};

MyQueue.prototype.pop = function () {
  // 假如 stack2 为空，需要将 stack1 的元素转移进来
  if (this.stack2.length <= 0) {
    // 当 stack1 不为空时，出栈
    while (this.stack1.length !== 0) {
      // 将 stack1 出栈的元素推入 stack2
      this.stack2.push(this.stack1.pop());
    }
  }
  // 为了达到逆序的目的，我们只从 stack2 里出栈元素
  return this.stack2.pop();
};

MyQueue.prototype.peek = function () {
  if (this.stack2.length <= 0) {
    // 当 stack1 不为空时，出栈
    while (this.stack1.length != 0) {
      // 将 stack1 出栈的元素推入 stack2
      this.stack2.push(this.stack1.pop());
    }
  }
  // 缓存 stack2 的长度
  const stack2Len = this.stack2.length;
  return stack2Len && this.stack2[stack2Len - 1];
};

MyQueue.prototype.empty = function () {
  // 若 stack1 和 stack2 均为空，那么队列空
  return !this.stack1.length && !this.stack2.length;
};
```

### 队列的进阶-双端队列

前面说过，队列可以双向进出。那么**队列也可以允许在同一端进行插入和删除**，对于编程而言，最常见的载体是既允许使用 pop、push 同时又允许使用 shift、unshift 的数组。这种队列我被称为**双端队列**。由双端队列衍生出的题目可谓是五花八门，也是算法中备受推崇的一个热点命题。

那么简单介绍结束之后，我们来学习一下双端队列特征和使用

**滑动窗口问题**

给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。

```js
nums = [1,3,-1,-3,5,3,6,7]
k = 3
// 输出 [3,3,5,5,6,7]
```

**解法一：快慢双指针法**

算是简单回顾一下之前的方法，我们先用一个“淳朴”的方法先来解决一下，打开思路。

1. 用快慢双指针先选定区间范围，形成一个“窗口”，逐渐移动
2. 在“窗口”范围内，找出最大值，并记录下来

```js
function maxSlidingWindow (nums, k) {
  // 声明结果数组和最大长度
  const res = []
  const len = nums.length
	
  // 确定快慢指针的位置范围
  let l = 0
  let r = k - 1
	
  // 遍历数组
  while ( r < len) {
    const arr = []
		
    // 将窗口内的数字存入
    for (let i = l; i <= r; i++) {
      arr.push(nums[i])
    }
		
    // 找出窗口内最大值
    res.push(Math.max(...arr))
		
    // 窗口移动
    l++
    r++
  }

  return res
}
```

这个解法简单暴力，性能也还凑活，不用担心超时，就算是当做算法题的解法，也是完全ok的。

但是这个解法并不是很优质的解法，因为他不可避免的多次进行了循环，那么我们就要深入研究一下更加优质的解法了。

**解法二：双端队列法**

打开思路之后，我们就有请我们本节的主角，双端队列登场，我们看一下如何使用双端队列解决问题。

我们先来想一下上一个解法的缺陷，我们每次滑动窗口之后，都不可避免的要把窗口内的所有数组进行遍历、排序、比较，最后得出我们想要的结果，这样就造成了每次滑动窗口都要进行重复的遍历。可能窗口滑动之后，窗口内的数据最大值没有变化，但我们依然需要进行一系列步骤来找出最大值。

既然我们找出缺陷所在，我们可以试想一下，我们可不可以在窗口滑动的时候只根据元素的变化更新最大值，这样我们可以直接取出最大值，提高性能！想到这点，那我们已经成功不远了！我们可以维护一个**递减趋势**的双端队列，下面来理一下思路。

1. 我们先把遍历到的每一个元素推入队列中
2. 在推入元素之前，和队尾元素进行比较。如果当前元素小于队尾元素，则正常入队。如果当前元素大于队尾元素，那么我们的递减趋势被打破，从队尾开始将小于当前元素的元素依次出列(由于是双端队列，我们从队尾出队完全没问题)，此时队头的数字永远保持最大值。
3. 当遍历到的元素达到k的时候，意味着我们第一个窗口最大值已经产生了，这时取出队头的元素，把他push到结果数组中
4. 继续遍历原数组，在每走一步的时候，重复上面几步，维护递减趋势的双端队列，填充结果数组

下面我们来实现以下

```js
function maxSlidingQequeWindow (nums, k) {
  // 原数组长度
  const len = nums.length
  // 结果数组
  const res = []
  // 双端队列数组
  const deque = []

  for (let i = 0; i < len; i++) {
    // 要点：构造递减队列
    // 当队尾元素小于当前元素时，把前一个索引值出列，直到队尾元素大于等于当前元素
    while (deque.length && nums[deque[deque.length - 1]] < nums[i]) {
      deque.pop()
    }

    // 入队当前元素索引（注意是索引）
    deque.push(i)
    
    // 每次都需要剔除超出滑动窗口范围的元素
    // i - k 是当前滑动窗口的最小索引值
    while (deque.length && deque[0] <= i - k) {
      deque.shift()
    }

    // 因为队列是递减队列，所以只需取第一个数字即为最大的数，但是只有在被遍历的元素个数大于 k 的时候，才更新结果数组，即i>=k-1
    if (i >= k - 1) {
      res.push(nums[deque[0]])
    }
  }
  return res
}
```

使用双端队列法，我们成功避免了内部对滑动窗口多次遍历、排序的问题。从上面的例子中，我们可以总结一下可以使用双端队列法类型的特点：队列的**递减性**以及**有效性**。

## 算法思想-DFS与BFS

说起算法，DFS（深度优先搜索）和BFS（广度优先搜索）是我们必须接触的一环，注意用词，是【必须】哦！因为他属于算法的基础思想。我们下面开始算法学习时候，先来补补课，认识一下这两个大兄弟。

### 初识DFS（深度优先搜索）

相信我们都玩儿过迷宫游戏，我们在走迷宫的时候，不论怎么选分支路线，都会走到底，如果是死路，才会返回之前的节点在进行探索。这种方式可以理解为使用了深度优先搜索的方式。

那么从迷宫游戏中我们可以简单地先来总结一下深度优先搜索的核心原则，那就是**一条路走到底，在没有走到底之前，不会回头选择其他路线，这样以深度为优先的搜索方式，就是深度优先搜索**。

### 初识BFS（广度优先搜索）

同样是迷宫游戏，我们可以换一种走法，我们每走到一个岔口的时候，都先总结一下他有几个分支几条路。一层一层的往下走，而不是一条路走到底。这种方式可以理解为使用了广度优先搜索的方式。

我们来简单总结一下广度优先搜索的核心原则，那就是**分析每层有几个子节点，先把每一层的子节点全部遍历之后，再去走下一层，直到遍历结束为止，这样以广度为优先的搜索方式，就是广度优先搜索**。

## 算法思想-递归与回溯(剪枝)思想

认识完DFS与BFS，下面我们真正的接触一下算法思想，其实算法离我们并不远。在日常项目中就会运用到算法思想，比如**递归**。这个对我们而言是比较熟悉的一种思想，在我们进行不确定深度层级的遍历的时候，总能用到它。今天我们也不长篇大论的来讨论所谓的【思想】，这个对于我们来说用处没那么大，个人认为算法这个东西，不是用来吹水，显得自己逼格够高的一种资本，而是希望能够切切实实帮助我们解决问题的，所以我们还是通过解题来慢慢的摸索他们的本质。

### 递归套路的第一个碰面

我们先来做leetcode淘来的一道【组合问题】的经典题型，**数组全排列问题**。虽然这道题算easy难度，但是真的很适合入门练手，大家也可以细品一下这道题。

>题目描述：给定一个**没有重复**数字的序列，返回其所有可能的全排列。



> 示例：  
> 输入: [1,2,3]
> 输出: [
> [1,2,3],
> [1,3,2],
> [2,1,3],
> [2,3,1],
> [3,1,2],
> [3,2,1]
> ]



这个题其实就是我们上学时候的排列组合题，但是计算机没有公式，需要我们**穷举**出所有的排列可能性。注意到我刚才说的【穷举】哦，这个其实就是解决组合问题的关键字。

说道【穷举】我们第一个反应应该想到DFS(深度优先搜索)就没错啦，DFS的核心是什么呢？就是递归！

那么下面不管大家是新手，还是老手，都一起想想怎么完成这个递归！

就拿上面的[1, 2, 3]来举例，我们怎么进行穷举呢？

1. 第一步有三种选择1，2，3，假设我们拿到了1。
2. 第二步的时候他有两种选择，2或者3，假设我们拿到了2。
3. 第三步根据第二步的选择，只剩下一种选择，而能选的数字只剩下了3。

所以我们从这里看出，可能性一共有3✖️2✖️1=6。但可惜的是，我们是要求他们的组合，那么我们如何根据上面的穷举来进行递归呢？我们再来分析一下。

1. 我们可以把每一步想成一个坑位，数组的length即是有多少个坑位待填充。
2. 遍历数组，让每一个数字都可以成为第一个坑位。
3. 在每次循环时候，走完了第一个坑位，调用当前方法进行递归，走到下一个坑位，那么什么时候算本轮次递归结束呢？那当然是length等于数组长度，即所有坑位被填满的时候。
4. 每轮次递归结束后，将数组push到结果数组中，循环结束，我们就得到了完全排列的数组。

下面我们来用代码实现一下：

```js
function permute (nums) {
  // 坑位的长度
  const len = nums.length
  
  // 当前轮次递归，进行排列的数组内容
  const cur = []
  
  // 记录本轮次已经用过的数字 避免使用重复数字
  const visited = {}
  
  // 所有存在的排列顺序的结果数组
  const res = []
  
  // 深度遍历方法 接收排列的索引值 即我们一直在说的坑位
  function dfs (nth) {
    // 当前正在排列的一个数组所有坑位都被占满的时候 返回排列好的数组
    if (nth === len) {
      return res.push([...cur])
    }
    
    // 在当前第nth个坑位中，递归遍历所有的数字，穷举排列可能
    for (let i = 0; i < len; i++) {
      const n = nums[i]
      // 如果当前数字没被使用过，则放入当前排列的数组中
      if (!visited[n]) {
        // 放入当前排列的数组中
        cur.push(n)

        // 打上已经用过的标记
        visited[n] = 1

        // 走到下一个坑位继续去深度遍历其他的值
        dfs(nth + 1)

        // 遍历结束后 让出当前数组中的坑位
        cur.pop()

        // 释放当前的标记
        visited[n] = 0
      }
    }
  }
  
  // 从第一个坑位开始遍历
  dfs(0)
  
  return res
}
```

虽然代码行数不多，并且都有注释，相信第一次接触的同学们可能还是一脸懵，个人认为这道题不理解的话可以多花点时间看看，千万别因为是一道easy难度的题就小看了他，因为它包括了最核心的dfs思想，以及递归式的核心概念**重复**和**边界**。

### 不同的题目，相同的套路

下面我们来加深一下递归核心概念的掌握和理解，把这道题小小的改变一下！

> 题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
> 说明：解集不能包含重复的子集。



> 示例: 输入: nums = [1,2,3]
> 输出:
> [
> [3],
> [1],
> [2],
> [1,2,3],
> [1,3],
> [2,3],
> [1,2],
> []
> ]

这道题和上面的题大同小异，不一样的是他并不需要原始数组的全排列方式，而是要得出数组的全组合方式。我们来思考一下，这道题虽然换了一个表现形式，归根结底还是需要利用【穷举法】来得出结果，截然这样，基本上是用**DFS**来解决了，老办法我们先来寻找一下他们如何”占坑位“：

1. 第一步有三种选择，假设我们拿到了1。
2. 第二步有三种选择，空，2，或者3。如果取到了空则没必要继续走，否则再走下一步。假设我们拿到了2。
3. 第三步有两种选择，空或者3。两种选择得出两个结果。

明白了如何占坑位，那我们来看下递归的方式：

1. 一次遍历让所有的数字均能成为第一个数字。
2. 检查我们手里还剩下哪些数字，填充一个继续往下走，或者选择空直接结束本次递归。
3. 长度超出3个则认为是超出递归边界

下面用代码实现一下：

```js
function subsets (nums) {
  // 递归边界长度
  const len = nums.length

  // 当前排列的数组内容
  const cur = []

  // 所有存在的排列顺序
  const res = []

  // 深度遍历方法 接收排列的索引值
  function dfs (nth) {
    // 每次进入 必然是一个不重复的子集 直接push即可
    res.push([...cur])

    // 每次都从下一次开始遍历 不需要走重复的数字
    for (let i = nth; i < len; i++) {
      // 这是当前数字存在于组合中的情况
      cur.push(nums[i])
      // 基于当前数字存在于组合中的情况，进一步 dfs
      dfs(i + 1)
      // 这是当前数字不存在与组合中的情况 即取空
      cur.pop()
    }
  }

  // 从数组的第0个开始
  dfs(0)

  return res
}

subsets([1, 2, 3])
```

这个解法其实光看代码来讲，比上面的更加抽象一些，希望可以认真的盘一下这个解法。

