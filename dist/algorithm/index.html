<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>目录 | 小乐的技术分享</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="前端知识记录分享">
    
    <link rel="preload" href="/assets/css/0.styles.1a54c77b.css" as="style"><link rel="preload" href="/assets/js/app.18f5c49f.js" as="script"><link rel="preload" href="/assets/js/2.3a20e52e.js" as="script"><link rel="preload" href="/assets/js/8.ee7f20e5.js" as="script"><link rel="prefetch" href="/assets/js/10.17e01bb8.js"><link rel="prefetch" href="/assets/js/11.d96dddca.js"><link rel="prefetch" href="/assets/js/12.ba77acf3.js"><link rel="prefetch" href="/assets/js/13.98915912.js"><link rel="prefetch" href="/assets/js/3.6aeb180a.js"><link rel="prefetch" href="/assets/js/4.05a5936c.js"><link rel="prefetch" href="/assets/js/5.fdfdb89f.js"><link rel="prefetch" href="/assets/js/6.11849f16.js"><link rel="prefetch" href="/assets/js/7.242ff817.js"><link rel="prefetch" href="/assets/js/9.cda742cb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1a54c77b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">小乐的技术分享</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="https://segmentfault.com/u/yagenl" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Segmentfault主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/GenXiaoLe" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="https://segmentfault.com/u/yagenl" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Segmentfault主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/GenXiaoLe" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/nodeBasis/" class="sidebar-link">node基础</a></li><li><a href="/vue2Basis/" class="sidebar-link">vue2基础</a></li><li><a href="/project/" class="sidebar-link">项目应用</a></li><li><a href="/webProject/" class="sidebar-link">服务端部署</a></li><li><a href="/algorithm/" aria-current="page" class="active sidebar-link">前端算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/#目录" class="sidebar-link">目录</a></li><li class="sidebar-sub-header"><a href="/algorithm/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/algorithm/#数据结构-数组" class="sidebar-link">数据结构-数组</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/#强大的指针" class="sidebar-link">强大的指针</a></li></ul></li><li class="sidebar-sub-header"><a href="/algorithm/#数据结构-字符串" class="sidebar-link">数据结构-字符串</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/#指针的妙用" class="sidebar-link">指针的妙用</a></li></ul></li><li class="sidebar-sub-header"><a href="/algorithm/#数据结构-链表" class="sidebar-link">数据结构-链表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/#链表的表现形式" class="sidebar-link">链表的表现形式</a></li><li class="sidebar-sub-header"><a href="/algorithm/#来一个链表生成的简易方法" class="sidebar-link">来一个链表生成的简易方法</a></li><li class="sidebar-sub-header"><a href="/algorithm/#链表的基础使用" class="sidebar-link">链表的基础使用</a></li><li class="sidebar-sub-header"><a href="/algorithm/#复杂链表的使用" class="sidebar-link">复杂链表的使用</a></li></ul></li><li class="sidebar-sub-header"><a href="/algorithm/#数据结构-栈" class="sidebar-link">数据结构-栈</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/#栈的概念" class="sidebar-link">栈的概念</a></li><li class="sidebar-sub-header"><a href="/algorithm/#简易的栈方法" class="sidebar-link">简易的栈方法</a></li><li class="sidebar-sub-header"><a href="/algorithm/#初识栈结构" class="sidebar-link">初识栈结构</a></li><li class="sidebar-sub-header"><a href="/algorithm/#栈问题的进阶" class="sidebar-link">栈问题的进阶</a></li></ul></li><li class="sidebar-sub-header"><a href="/algorithm/#数据结构-队列" class="sidebar-link">数据结构-队列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/#队列的概念" class="sidebar-link">队列的概念</a></li><li class="sidebar-sub-header"><a href="/algorithm/#简易的队列方法" class="sidebar-link">简易的队列方法</a></li><li class="sidebar-sub-header"><a href="/algorithm/#初识队列结构" class="sidebar-link">初识队列结构</a></li><li class="sidebar-sub-header"><a href="/algorithm/#队列的进阶-双端队列" class="sidebar-link">队列的进阶-双端队列</a></li></ul></li><li class="sidebar-sub-header"><a href="/algorithm/#算法思想-dfs与bfs" class="sidebar-link">算法思想-DFS与BFS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/#初识dfs-深度优先搜索" class="sidebar-link">初识DFS（深度优先搜索）</a></li><li class="sidebar-sub-header"><a href="/algorithm/#初识bfs-广度优先搜索" class="sidebar-link">初识BFS（广度优先搜索）</a></li></ul></li><li class="sidebar-sub-header"><a href="/algorithm/#算法思想-递归与回溯-剪枝-思想" class="sidebar-link">算法思想-递归与回溯(剪枝)思想</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/#递归套路的第一个碰面" class="sidebar-link">递归套路的第一个碰面</a></li></ul></li></ul></li><li><a href="/article/" class="sidebar-link">个人拓展文章</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="目录"><a href="#目录" class="header-anchor">#</a> 目录</h2> <ol><li>前言</li> <li>数据结构-数组</li> <li>数据结构-字符串</li> <li>数据结构-链表</li> <li>数据结构-栈</li> <li>数据结构-队列</li> <li>数据结构-二叉树(待更新)</li> <li>数据结构-堆(待更新)</li> <li>算法思想-DFS与BFS</li> <li>算法思想-递归与回溯(剪枝)思想</li> <li>算法思想-好用到爆的套路之动态规划(待更新)</li></ol> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>小葵花妈妈课堂开课咯！</p> <p>数据结构对于我们来讲是很重要的一环，掌握数据结构以及使用也是作为程序员的必须要求，对于提升编程能力和代码质量有很大的作用。</p> <p>同时，随着数据结构的深入学习，我们绕不开的一环就是被称为编程中的修仙玄学：<strong>算法</strong>。</p> <p>我们这里主要以干货为主，也不整虚头巴脑的了，直接就从数据结构入手，在认识数据结构的同时，逐步进行基础的算法学习。</p> <p>奥利给，干就完了！</p> <h2 id="数据结构-数组"><a href="#数据结构-数组" class="header-anchor">#</a> 数据结构-数组</h2> <blockquote><p>万里长征第一步，咱们就从数组入手。数组是我们最经常接触的数据结构的一种，不管是栈还是队列的使用，都能在数组中体现，这些会在后续中介绍，我们先把数组当成开胃菜，简单地搞搞。</p></blockquote> <p>对于数组就不花费时间来介绍了，都是老熟人了。直接就上题目！</p> <h3 id="强大的指针"><a href="#强大的指针" class="header-anchor">#</a> 强大的指针</h3> <p>说起数据结构与算法，指针法可是业界公认的解题好手，我们这里先简单的认识一下指针，后续再做更多的应用！</p> <p>指针的主要作用是标记作用，用来标记某个结点，也被称作游标，最常用的是双指针法，对于复杂的问题也有多指针解法。</p> <p>双指针的用处很多，常用的有快慢指针法和对撞指针法。比如vue2中的diff算法，使用的是两对双指针对撞指针的算法。下面我们来做几道题感受一下指针的用处！</p> <p><strong>合并两个有序数组</strong></p> <p>我们现在有两个数组[1, 2, 3, 5]，[2, 4, 6]，我们要把两个数组合并成一个有序数组[1, 2, 2, 3, 4, 5, 6]。也不绕弯了，这道题标准解法就是双指针法，也是双指针法的基础用法。</p> <p>这里我们稍缓节奏，先缕一下思路：</p> <p>1.先对每个数组分别定义一个指针，指向数组的索引值0位。并声明一个空数组</p> <p>2.如果第一个指针的数字小于第二个指针的数字，则把第一个指针的数字push到空数组中，指针向前走一位。否则push第二个指针的数字，第二个指针向前走一位。如果相等，则都push进去，两个指针均向前一位。</p> <p>3.如果有一个数组已经先遍历完，另一个数组还有剩余，则直接push到数组最后面</p> <p>好了，思路有了，我们来实现代码</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">merge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums1<span class="token punctuation">,</span> nums2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment">// 当两个数组都没遍历完时，指针同步移动</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
          i<span class="token operator">++</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
          j<span class="token operator">++</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
          arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
          i<span class="token operator">++</span>
          j<span class="token operator">++</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// nums2或者nums1 留下的情况，特殊处理一下 这里就不写了</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p><strong>三数求和问题</strong></p> <p>认识了指针法之后，我们来一道数组经典中的经典题，三数求和问题，即给定一个数组，给定一个固定值，求数组中哪三个数相加能够得到我们的固定值。这道题刚入手相信大家的解法都是层层遍历嵌套，来寻找集合，但是我们使用双指针的对撞指针解法能够轻松而又优雅的解决。</p> <p>刚开始讲究循序渐进，老规矩还是先理一下解题思路。</p> <p>1.我们可以对数组进行排序，转化为有序数组</p> <p>2.固定一个数字，然后在头尾各设置一个指针，三个数相加看是否符合规定。</p> <p>3.如果三数之和比固定值大，说明右侧的数偏大了，右指针左移。</p> <p>4.如果三数之和比固定值小，说明左侧的数偏小了，左指针右移。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">threeSum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> count</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 用于存放结果数组</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> 
    <span class="token comment">// 给 nums 排序</span>
    nums <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token operator">-</span>b
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token comment">// 缓存数组长度</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length
    <span class="token comment">// 注意我们遍历到倒数第三个数就足够了，因为左右指针会遍历后面两个数</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 左指针 j</span>
        <span class="token keyword">let</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span> 
        <span class="token comment">// 右指针k</span>
        <span class="token keyword">let</span> k<span class="token operator">=</span>len<span class="token operator">-</span><span class="token number">1</span>   
        <span class="token comment">// 如果遇到重复的数字，则跳过</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&gt;</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">===</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 三数之和小于count，左指针前进</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>
                j<span class="token operator">++</span>
               <span class="token comment">// 处理左指针元素重复的情况</span>
               <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>k<span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">===</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    j<span class="token operator">++</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&gt;</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment">// 三数之和大于count，右指针后退</span>
                k<span class="token operator">--</span>
               
               <span class="token comment">// 处理右指针元素重复的情况</span>
               <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>k<span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">===</span>nums<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    k<span class="token operator">--</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 得到目标数字组合，推入结果数组</span>
                res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                
                <span class="token comment">// 左右指针一起前进</span>
                j<span class="token operator">++</span>  
                k<span class="token operator">--</span>
               
                <span class="token comment">// 若左指针元素重复，跳过</span>
                <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>k<span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">===</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    j<span class="token operator">++</span>
                <span class="token punctuation">}</span>  
               
               <span class="token comment">// 若右指针元素重复，跳过</span>
               <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>k<span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">===</span>nums<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    k<span class="token operator">--</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 返回结果数组</span>
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br></div></div><p>在上面这道题中，左右指针一起从两边往中间位置相互迫近，这样的特殊双指针形态，被称为“对撞指针”。那么数组什么时候可以使用对撞指针呢？我们需要注意一个关键词：<strong>有序</strong>。</p> <p>好了，数组就先介绍到这里。之后在栈和队列中有更加深入的介绍。</p> <h2 id="数据结构-字符串"><a href="#数据结构-字符串" class="header-anchor">#</a> 数据结构-字符串</h2> <blockquote><p>字符串作为基础数据类型，相信也不用多说了，并且字符串重点难点更多在于隐式转换以及正则部分，算法涉及到的相对较少，这里也仅仅做一个而简单的介绍，用来抛砖引玉。</p></blockquote> <h3 id="指针的妙用"><a href="#指针的妙用" class="header-anchor">#</a> 指针的妙用</h3> <p><strong>字符串反转</strong></p> <p>这个属于基础类型，相信大家都是信手捏来</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 定义被反转的字符串 </span>
<span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'abcdefg'</span>  
<span class="token comment">// 定义反转后的字符串</span>
<span class="token keyword">const</span> res <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>回文判断</strong></p> <p>回文判断是字符串考题中的常见题型，衍生题型也很多，我们这里用几个例子来举例。</p> <p>回文字符串，就是正着读和倒着读都一样的字符串，这道题解法有很多，比如我们上面的反转字符串解法就能解决，也可以利用双指针对撞的方式，或者利用回文字符串的对称性从中间劈开判断两边的字符是否相等，都是非常好用的方法，我们选择一种方法来实现。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 双指针判断</span>
<span class="token keyword">function</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缓存字符串的长度</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span>length

  <span class="token comment">// i、j分别为左右指针</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span>
  
  <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果左右指针指向的字符不同，则不是回文，否则两个指针向中间靠拢</span>
   	<span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> str<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    i<span class="token operator">++</span>
    j<span class="token operator">--</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>

<span class="token comment">// 利用回文对称性特性</span>
<span class="token keyword">function</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 缓存字符串的长度</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> str<span class="token punctuation">.</span>length
    <span class="token comment">// 遍历前半部分，判断和后半部分是否对称</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!==</span>str<span class="token punctuation">[</span>len<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p><strong>回文判断衍生题</strong></p> <p>下面我们来一道回文判断的衍生题。</p> <p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 例子：</span>
abboa <span class="token comment">// true 删掉o 字符串变为回文</span>
abbona <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>其实看完上一道题的解法，我们应该对这道题有了基本的思路，真相只有一个(bushi)，还是利用双指针，只不过要做一丢丢改造。如果碰到不是回文的情况，给他一个机会，左指针或者右指针移动一次，看是否能够维持回文的对称特性。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">validPalindrome</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 缓存字符串的长度</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span>length

    <span class="token comment">// i、j分别为左右指针</span>
    <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> j<span class="token operator">=</span>len<span class="token operator">-</span><span class="token number">1</span>
    
    <span class="token comment">// 当左右指针均满足对称时，一起向中间前进</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">===</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        i<span class="token operator">++</span> 
        j<span class="token operator">--</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 尝试判断跳过左指针元素后字符串是否回文</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 尝试判断跳过右指针元素后字符串是否回文</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 工具方法，用于判断字符串是否回文</span>
    <span class="token keyword">function</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token parameter">st<span class="token punctuation">,</span> ed</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>st<span class="token operator">&lt;</span>ed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>st<span class="token punctuation">]</span> <span class="token operator">!==</span> s<span class="token punctuation">[</span>ed<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span>
            <span class="token punctuation">}</span>
            st<span class="token operator">++</span>
            ed<span class="token operator">--</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 默认返回 false</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>好了，数组和字符串就暂时介绍到这里了，对于指针我们也有了基本的认识和概念。开胃菜已经差不多了，下面我们开始进入正题，去探究一下数据结构预算法的魅力所在！</p> <h2 id="数据结构-链表"><a href="#数据结构-链表" class="header-anchor">#</a> 数据结构-链表</h2> <blockquote><p>链表在数据结构中是非常重要的一个点，因为他每个节点都是按顺序链接，排列，就像一根链子连起来的一样，因此具有很强的前后关联性。可以通过简单地循环轻松进行节点的增删改查操作，是性能非常高的一种数据结构</p></blockquote> <h3 id="链表的表现形式"><a href="#链表的表现形式" class="header-anchor">#</a> 链表的表现形式</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> head <span class="token operator">=</span> <span class="token punctuation">{</span>
  val<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  next<span class="token operator">:</span> <span class="token punctuation">{</span>
    val<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    next<span class="token operator">:</span> <span class="token punctuation">{</span>
      val<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
      next<span class="token operator">:</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="来一个链表生成的简易方法"><a href="#来一个链表生成的简易方法" class="header-anchor">#</a> 来一个链表生成的简易方法</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> val<span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token punctuation">(</span>next <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> next<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="链表的基础使用"><a href="#链表的基础使用" class="header-anchor">#</a> 链表的基础使用</h3> <blockquote><p>上面介绍了链表进行了基础介绍，也展示了链表的表现形式以及生成方法，相信大家对于链表已经有了一丢丢的了解，下面我们通过一些实战来看一下链表到底怎么玩</p></blockquote> <ol><li>双链表合并</li></ol> <p>最开始我们先来一个开胃菜。现在假设我们有两个链表<code>1-&gt;5-&gt;7-&gt;9</code>和<code>2-&gt;3-&gt;6-&gt;8</code>，那我们怎么把两个链表按顺序整合在一起，组成一个按顺序排列的新链表呢？大家可以先想一下解决方案。</p> <p>如果是数组结构，两个数组我们至少要进行两次循环遍历才能解决问题。但是对于链表结构而言，只需要一次遍历！大家对于链表结构的优秀性能是否有了一些认识呢，下面我们来实操一波。</p> <p>先整理一下思路，我们要将两个链表按顺序整合，如果把链表的节点想象成一个个的扣子，那么我们需要一根<strong>线</strong>来把他们按顺序穿起来，我们现在需要做的就是创造这样的一根<strong>线</strong>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> head
  
  <span class="token comment">// 循环遍历知道left或者right结束为止</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">||</span> <span class="token operator">!</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果是左侧的大 则先把右侧的“穿进去”</span>
      cur<span class="token punctuation">.</span>next <span class="token operator">=</span> right
      <span class="token comment">// 右侧推进一步</span>
      right <span class="token operator">=</span> right<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 反之把左侧的“穿进去”</span>
      cur<span class="token punctuation">.</span>next <span class="token operator">=</span> left
      <span class="token comment">// 左侧推进一步</span>
      left <span class="token operator">=</span> left<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span>
    
    <span class="token comment">// “线”推进一步</span>
    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 如果结束后left或right还有没遍历到的，则拼到最后</span>
  cur<span class="token punctuation">.</span>next <span class="token operator">=</span> left <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> left <span class="token operator">:</span> right
  
  <span class="token keyword">return</span> cur<span class="token punctuation">.</span>next
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><ol start="2"><li>链表节点的删除</li></ol> <p>上面的例子展示了链表结构的高性能。但是呢，对于他的特点，表现得还不是特别明显，那么我们再通过一个例子来展示一下链表相较于其他结构特殊的地方，也就是节点的特性。</p> <p>我们现在有一个这样的链表<code>1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;4-&gt;5-&gt;6</code>，我们要把重复的节点2，3删掉，最后新的链表为<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</code>。</p> <p>对于数组而言，抛开es6提供的去重方法等，常规解决方法是新建一个空数组，对原数组进行遍历，如果没有找到push，找到则继续遍历。</p> <p>那么对于链表而言我们只需要判断当前节点和下一个节点是否重复，如果重复则直接删除下一个节点，不重复继续，那么如何删除呢？我们只需要把当前节点和下下个节点连接就ok了，重复节点会被直接干掉。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deleteNodeList</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> head
  
  <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">===</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果重复，则干掉下一个重复的节点</span>
      cur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 否则，推进链表继续遍历</span>
      cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> head
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这个例子我们展示了链表的一个特性，即节点之间的强关联性，每个节点之间都是相关的，从本质上我们只需要建立节点之间的联系，就能完成一系列的操作。这个问题其实看起来很简单，只有几行代码，是一道很经典的基础数据结构题。虽然只是利用了链表的基础特性，但是在我接触的人中，对于这道题目没思路的，写不完整的，写完跑不起来的大有人在，还是希望大家可以去多多思考、理解链表结构的本质。</p> <ol start="3"><li>链表节点的删除问题的拓展(dummy节点登场)</li></ol> <p>下面我们把这个节点的删除问题延伸一下，上面的是我们只删除重复节点，那么下面我们加一点点难度，只要有重复的，就把重复节点全部删掉。</p> <p>我们现在有一个这样的链表<code>1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;4-&gt;5-&gt;6</code>，因为2，3节点有重复，我们把重复的节点2，3全部删掉，最后新的链表为<code>1-&gt;4-&gt;5-&gt;6</code>。</p> <p>对于数组的而言(数组：请打开麦克风交流，为什么针对我？)，这个操作就就很烦，因为数组前后的值缺乏关联性，还需要在查到有重复值时候，反复遍历新数组，把重复的值干掉。无论怎么优化复杂度至少n2，一个写不好甚至还要往上。</p> <p>但是对于链表的话，这个问题就是so easy，我们只需要利用链表的节点关联特性，对上面的方法做一点点的优化。下面我们要引入一个处理链表的常用概念<code>dummy</code>节点。</p> <p><strong>dummy节点是什么</strong>：</p> <p>​	其实说白了就是一个首节点游标是空的链表。因为链表的特殊结构，他必须有一个起点，如果把起点干掉了，这个链表也会抛错。那么为了让原链表头部可以被删除，我们需要创建一个起点为空的链表来承接原链表，这就是dummy节点，下面我们用代码来直观的看一下。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> head <span class="token operator">=</span> <span class="token punctuation">{</span>
  val<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  next<span class="token operator">:</span> <span class="token punctuation">{</span>
    val<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    next<span class="token operator">:</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> dummy <span class="token operator">=</span> <span class="token punctuation">{</span>
  val<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  next<span class="token operator">:</span> head
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>那么既然有了dummy节点，我们就来解决一下上面这个问题</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deleteDuplicates</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head
  
  <span class="token keyword">let</span> cur <span class="token operator">=</span> dummy
  
  <span class="token comment">// 下个节点和下下各节点都存在的时候</span>
  <span class="token comment">// 注：这么写是因为dummy起点为空哦</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 对 cur 后面的两个结点进行比较 如果相同</span>
      <span class="token keyword">let</span> val <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val
      <span class="token comment">// 将所有相同节点全部干掉，反复地排查后面的元素是否存在多次重复该值的情况</span>
      <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 两个节点不同则直接推进到下一个节点</span>
      cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>我们通过两个例子认识了下链表的基础特性，对于简单链表也有了基本的操作能力。那么下面咱们就升级一下难度，来点有意思的，玩一玩复杂链表和环形链表，下面的内容可能有些难度，涉及到了指针(游标)、多指针、快慢指针、Map标记链表等知识，还是希望大家多花时间琢磨一下。</p> <h3 id="复杂链表的使用"><a href="#复杂链表的使用" class="header-anchor">#</a> 复杂链表的使用</h3> <p>上面我们通过几个例子，简单地认识了链表的特性和使用，因为上面的例子中的链表结构都是有序的，处理的时候省了很多事情。但是对于大多的链表结构往往是没有特定规律，那么我们怎么去处理这些链表呢？下面我们引入**指针(游标)**的概念。</p> <p>指针简单地来说起到的是标记链表位置的作用，也可以称作游标，在上面的数组介绍中，我们已经使用过指针了，下面我们利用指针来处理一下链表问题。</p> <ol><li><strong>双指针法</strong></li></ol> <blockquote><p>双指针通常的用法是，快慢指针以及对撞指针，我们的例子中均会有涉及到，这里我们先用快慢指针来处理一个简单问题</p></blockquote> <p><strong>删除某个区间的节点：</strong></p> <p>我们现在有一个链表<code>1-&gt;5-&gt;4-&gt;8-&gt;10-&gt;3-&gt;7</code>，我们现在要做的是需要删除某个区间的所有节点。这个功能对于数组很简单，对于链表直接遍历也可以处理，没什么难度。但是我们既然要玩儿花的，就用快慢指针来解决问题，当然这个有点杀鸡用牛刀，反而增加了复杂度，不过也是先体验一把。</p> <p>思路也很简单，我们知道区间是m, n，先设定一个快指针，先行n步，然后快慢指针同时前进，当慢指针前进到m步的时候，要删除的区间就出来了，我们直接干掉快慢指针中间的区域就ok，下面实现一波</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">removeNthFromEnd</span> <span class="token punctuation">(</span><span class="token parameter">head<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 引入dummy节点</span>
  <span class="token keyword">let</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head
	
  <span class="token comment">// 设定快慢指针，指向dummy节点起始处</span>
  <span class="token keyword">let</span> fast <span class="token operator">=</span> dummy
  <span class="token keyword">let</span> slow <span class="token operator">=</span> dummy

  <span class="token comment">// 快指针先行 和慢指针隔开n个位置</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>n <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next
    n<span class="token operator">--</span>
  <span class="token punctuation">}</span>
	
  <span class="token comment">// 快慢指针同时走</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>m <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
    m<span class="token operator">--</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 走完之后 慢指针已经停在了要删除的其实节点 连接快指针 干掉相应区间的节点</span>
  slow<span class="token punctuation">.</span>next <span class="token operator">=</span> fast<span class="token punctuation">.</span>next

  <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>看完这个例子有没有觉得指针很好玩呢？下面我们来搞一点有难度的。</p> <ol start="2"><li><strong>多指针法</strong></li></ol> <blockquote><p>顾名思义，多指针是存在多个指针，一般用来标记各个不同的点和位置，记录相应的状态，从而实现功能</p></blockquote> <p>下面我们要通过几个例子来感受一下链表中的【链】的本质。链表为何称之为链表，在我的理解看来，他就是一个<strong>链子</strong>，每个结点都连接着后续的所有结点，无论从某任意结点处断开，或者改变指针方向，都会形成新的链表。所以呢，<strong>处理链表的本质，是处理链表结点之间的指针关系</strong>。敲黑板哦！！！这个可是重点，链表的关键点全在这里。</p> <p><strong>全量反转颠倒链表(理解链表基础重点题目，要划重点哦！！！)</strong></p> <p>现在我们有一个链表1-&gt;2-&gt;3-&gt;4-&gt;5，我们要通过一个方法实现链表的完全反转，转化为5-&gt;4-&gt;3-&gt;2-&gt;1。</p> <p>因为链表无法直接从尾-&gt;头，所以最直接的办法是我们在头-&gt;尾的过程中不断地将当前节点的后续节点变为当前节点的前驱结点，即由1-&gt;2, 变为2-&gt;1。</p> <p>透过问题看本质，结合我们上面说的，其实就是把所有指针全部换一个方向就OK，把1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null变为null&lt;-1&lt;-2&lt;-3&lt;-4&lt;-5，对比着看是不是有点意思了呢？下面我们来使用<strong>多指针法</strong>操作cur(目标节点)，pre(目标节点的前驱节点)，next(目标节点的后续节点)这三个节点来实现一下。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reverseList</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 设定前驱节点为pre，第一次为null</span>
  <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token comment">// 目标节点为链表的第一个节点</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> head
	
  <span class="token comment">// 当没走到最后的时候继续循环</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先记录下当前结点所有后续节点</span>
    <span class="token keyword">let</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
    <span class="token comment">// 反转指针：把当前结点的指针指向前驱结点，实现相邻接点指针反转</span>
    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre
    <span class="token comment">// 前驱结点变为目标结点，前驱结点相当于往前走一步</span>
    pre <span class="token operator">=</span> cur
    <span class="token comment">// 由于指针反转之后，链表断开为两个链表，为了目标结点能继续走下去，需要把当前结点的指针指向后续结点，目标节点相当于也往前走一步</span>
    cur <span class="token operator">=</span> next
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 返回反转之后的链表</span>
  <span class="token keyword">return</span> pre
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>这个例子看完是不是完全懵了呢...什么改变指针方向....什么前驱后续的....其实这里不理解也肯正常，反转链表是个宝库，集成了链表大多的精华部分，吃透这道题，链表这个数据结构就掌握一半了！！！真心建议大家这个题反复的去看，去细品，一定会有很大收获！！！</p> <p><strong>局部反转链表</strong></p> <p>虽然反转链表有点难，但是咱们还是要成热打铁，结合前面学到的知识，再给反转链表加一丢丢的难度。</p> <p>下面我们来实现一个局部的反转链表，即1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7，转化为1-&gt;2-&gt;6-&gt;5-&gt;4-&gt;3-&gt;7。只反转一定范围内链表结构。</p> <p>这个怎么做呢，这个题咋一看这个有点难，但是我还是希望同学们看到这个题能有点点思路。</p> <p>其实翻翻上面提到的，无非不过是快慢双指针确定范围，再来一个范围内的全量反转链表。害，说了半天，不就是个缝合怪吗？</p> <p>那么咱们下面就来治治他！</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reverseBetween</span> <span class="token punctuation">(</span><span class="token parameter">head<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义前驱结点，目标结点</span>
  <span class="token keyword">let</span> pre<span class="token punctuation">,</span> cur<span class="token punctuation">,</span> leftHead
	
  <span class="token comment">// 来一个dummy结点，避免第一个结点处理不到</span>
  <span class="token keyword">const</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head

  <span class="token comment">// p相当于一个指针，指向链表的位置</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> dummy

  <span class="token comment">// 先走到要反转的链表起始位置</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p <span class="token operator">=</span> p<span class="token punctuation">.</span>next
  <span class="token punctuation">}</span>

  <span class="token comment">// 记录左边缘的全部结点</span>
  leftHead <span class="token operator">=</span> p

  <span class="token comment">// 开始反转的第一个节点</span>
  <span class="token keyword">let</span> start <span class="token operator">=</span> leftHead<span class="token punctuation">.</span>next

  <span class="token comment">// 前驱节点</span>
  pre <span class="token operator">=</span> start

  <span class="token comment">// 当前节点</span>
  cur <span class="token operator">=</span> pre<span class="token punctuation">.</span>next

  <span class="token comment">// 老规矩，开始在指定范围全量反转</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> m<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre
    pre <span class="token operator">=</span> cur
    cur <span class="token operator">=</span> next
  <span class="token punctuation">}</span>

  <span class="token comment">// 将反转后的链表拼接左边缘结点</span>
  leftHead<span class="token punctuation">.</span>next <span class="token operator">=</span> pre

  <span class="token comment">// 将区间反转后start也成为了最后一个结点，然后和cur之后未反转的结点连接</span>
  start<span class="token punctuation">.</span>next <span class="token operator">=</span> cur

  <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><p>其实u1s1，这个题的意义远不如上面的一道，不过也算是一个复杂链表理解的一个强化训练吧，就不多解释啦。</p> <p><strong>环形链表</strong></p> <p>既然讲链表，那么下面咱们来解锁一个特殊姿势的链表：<strong>环形链表</strong>。</p> <p>上面是环形链表呢？顾名思义，就是环形的链表，一般的链表像蛇一样，是一条线。而环形链表像贪吃蛇咬到自己的尾巴，变成了一个环，头就是尾，尾也是头。</p> <p>说不如练，咱们先来理解一下环形链表，做道小题，判断一个链表是否为环形链表。</p> <p><strong>判断链表是否为环形链表</strong></p> <p>1.flag法</p> <p>这个思路也很简单，一直往前走，走了重复的路，就代表是环形链表了呗。所以最简单的办法只需要在节点上面打一个flag，如果是环形链表，总能再次见到他。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">startCycleFlag</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> head

  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cur<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token boolean">true</span>
    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">this head is cycle，this start is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>cur<span class="token punctuation">.</span>val<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token string">'this head is not cycle'</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>2.升级版flag法</p> <p>由于直接在链表上打flag会造成数据污染，虽然只是简单的题目，我们也要尽量很优雅的解决。</p> <p>这里我们引入Map对象，每走一步都把目标结点存入Map中，如果存入之前在Map中找到了重复结点，则证明是环形链表。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">startCycleMap</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> cycleMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> head
  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cycleMap<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> cur
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      cycleMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> index<span class="token punctuation">)</span>
      cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next
      i<span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>3.快慢双指针法</p> <p>这个是设置两个指针，一快一慢，只要是环形链表，快指针一定能够追上慢指针。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isCycle</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> fast <span class="token operator">=</span> head
  <span class="token keyword">let</span> slow <span class="token operator">=</span> head

  <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 快指针走两步 慢指针走一步</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next

    <span class="token comment">// 如果相等则证明是环形链表</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>val <span class="token operator">===</span> slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> slow
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>定位环形链表的起始位置</strong></p> <p>环形链表的常见衍生题目就是寻找环形链表的起始位置，刚才的flag法可以简单暴力的解决我们的问题。但是，我们既然要学习，还是要多玩点花样，那么就用业界公认的快慢指针法来解决这个问题。</p> <p>快慢指针虽然可以判断链表是否为环形链表，但是却无法精确的判断起始位置。所以我们要利用下快慢指针的精髓！</p> <p>1.找出环形链表的长度N，让快指针先走N步，以保证他们的间隔是整个环形链表的长度。</p> <p>2.快慢指针同时往前走，当快慢指针重合时候，即头尾重合，也就是环形链表的起点！</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 判断是否是环形链表</span>
<span class="token keyword">function</span> <span class="token function">isCycle</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> fast <span class="token operator">=</span> head
  <span class="token keyword">let</span> slow <span class="token operator">=</span> head

  <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 快指针走两步 慢指针走一步</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next

    <span class="token comment">// 如果相等则证明是环形链表</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>val <span class="token operator">===</span> slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> slow
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>


<span class="token keyword">function</span> <span class="token function">startCycle</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> cycle <span class="token operator">=</span> <span class="token function">isCycle</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cycle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'this head is not cycle'</span>
  <span class="token punctuation">}</span>
	
  <span class="token comment">// 是环形链表 且此时快慢指针已经处在环形链表中了</span>
  <span class="token comment">// 计算环形链表的长度</span>
  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">let</span> fast <span class="token operator">=</span> cycle
  <span class="token keyword">let</span> slow <span class="token operator">=</span> cycle<span class="token punctuation">.</span>next
	
  <span class="token comment">// 慢指针走，计算链表长度</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>slow<span class="token punctuation">.</span>val <span class="token operator">!==</span> fast<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
    count<span class="token operator">++</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 重置快慢指针的位置</span>
  fast <span class="token operator">=</span> head
  slow <span class="token operator">=</span> head

  <span class="token comment">// 让快指针先行count步 保证他们间隔是一个环形链表的长度</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next
    count<span class="token operator">--</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 快慢指针同时进行</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token punctuation">.</span>val <span class="token operator">!==</span> slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next
    <span class="token comment">// 相遇时，即为头尾重合的时候，也就是环形链表的起点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>val <span class="token operator">===</span> slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">this start is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>fast<span class="token punctuation">.</span>val<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br></div></div><p>环形链表属于特殊的链表结构，也不需要过多纠结，能够通过上面的题目理解即可。但是常用链表结构还是需要多花一些掌握的。React中Diff的Fiber结构也是用链表来重写的，链表结构的优秀性能可见一斑。</p> <p>那么链表差不多就介绍到这里了，我们开始下一趴！</p> <h2 id="数据结构-栈"><a href="#数据结构-栈" class="header-anchor">#</a> 数据结构-栈</h2> <p><strong>队列</strong>和<strong>栈</strong>这两个兄弟比较微妙。因为这两者与其说是数据结构，不如说更像是一种处理数据的概念。并且我们在解决问题的时候，往往不会看到队列或者栈的关键字，但是他切切实实存在在诸多场景中。本节我们旨在学习栈的结构，队列放在后面再来说。</p> <h3 id="栈的概念"><a href="#栈的概念" class="header-anchor">#</a> 栈的概念</h3> <p>栈对于我们来讲并不陌生，经常接触的除了队列和栈，还有堆栈的概念。但是不管哪种，栈始终遵循的一个原则就是【先进后出】，即<strong>先被压入栈的必然在最后出栈</strong>。举个例子就好像我们吃黄桃罐头，最下面的必然是最先装进去的，但往往我们最后才能吃到。罐头瓶和栈一样是一个单向进出的结构，这个也是栈结构的常识，要和队列区分开。</p> <h3 id="简易的栈方法"><a href="#简易的栈方法" class="header-anchor">#</a> 简易的栈方法</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">stack</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>

  <span class="token function">pop</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">push</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  <span class="token function">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>result
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="初识栈结构"><a href="#初识栈结构" class="header-anchor">#</a> 初识栈结构</h3> <p>知道了什么是栈，我们来一个常见的场景来熟悉一下栈的使用。在我们进行自定义计算式是否有效的校验中，需要校验的一项是括号的使用是否正确，即括号是否成对出现。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// &quot;()&quot; =&gt; true</span>
<span class="token comment">// &quot;)(&quot; =&gt; false</span>

<span class="token comment">// 复杂一点</span>
<span class="token comment">// &quot;[()]&quot; =&gt; false</span>
<span class="token comment">// &quot;([)]&quot; =&gt; false</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这类校验怎么做呢？我们可以想一下，括号组意味着对称性，即如果有括号的后半部分，必然需要有对应的前半部分。通过我们上面的事例可以看出，如果是有效的括号组，遍历时遇到第一个右括号时，他的<strong>前一个值</strong>必然是他对应的左括号！而栈结构具有先进后出的特性，刚好可以在遇到后半部分的时候，查看一下栈顶的括号是否是他的前半部分，那下面我们就开始实现一下！</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 维护左括号和右括号的对应关系</span>
<span class="token keyword">const</span> leftToRight <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string">&quot;(&quot;</span><span class="token operator">:</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;[&quot;</span><span class="token operator">:</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;{&quot;</span><span class="token operator">:</span> <span class="token string">&quot;}&quot;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">isValid</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 空字符串无条件判断为 true</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 初始化栈数组</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">// 缓存字符串长度</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token comment">// 遍历字符串</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 缓存单个字符</span>
    <span class="token keyword">const</span> ch <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">===</span> <span class="token string">&quot;(&quot;</span> <span class="token operator">||</span> ch <span class="token operator">===</span> <span class="token string">&quot;{&quot;</span> <span class="token operator">||</span> ch <span class="token operator">===</span> <span class="token string">&quot;[&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 判断是否是左括号，如果是左括号，把匹配的右括号存入</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftToRight<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
     	<span class="token comment">// 若不是左括号，则必须是和栈顶的左括号相配对的右括号</span>
      <span class="token comment">// 若栈不为空，且栈顶的左括号没有和当前字符匹配上，那么判为无效</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span>length <span class="token operator">||</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 若所有的括号都能配对成功，那么最后栈应该是空的</span>
  <span class="token keyword">return</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>这个属于栈的基础应用，只是简单地认识一下栈结构，下面我们通过一道例题来深入了解一下栈结构。</p> <h3 id="栈问题的进阶"><a href="#栈问题的进阶" class="header-anchor">#</a> 栈问题的进阶</h3> <p>我们现在做一道真题。【根据每日气温列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。】</p> <p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p> <p>这道题最容易理解的是直接用双层遍历来暴力解决，第一层定位一个温度，第二层遍历来确定升温天数的index值，两个索引值相减得出间隔几天升温。</p> <p>但是，暴力解法往往是在我们没有好的方法时候使用，因为他的性能必然有相当大的缺陷。那么我们有更好的解法吗？答案是，当然有！</p> <p>我们可以审一下题，题目其实说升温，那么我们可以在遍历数组的时候先创建维持一个递减的数组，当有一个温度升高，打破了我们递减数组的平衡，那么我们需要找出数组中这个温度的<strong>前一个值</strong>，来计算两个值的索引差...等等！我刚才是不是说了前一个值，那么结合上一题，我们应该想到用栈的方法来解决这个题了。</p> <p>确定了方法之后，我们重新整理一下思路，我们可以在第一次遍历数组的时候，把所有元素的索引值依次入栈，维持一个递减的数组，如果一旦有元素打破了递减趋势，那么我们需要依次取出栈顶的索引值，计算出和当前索引值之差(升温天数)，直到栈清空或者继续维持递减趋势。记录升温天数的数组，就是我们要的最终答案！</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">dailyTemperatures</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始化数组的长度</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> <span class="token constant">T</span><span class="token punctuation">.</span>length
  
  <span class="token comment">// 初始化一个栈</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  
  <span class="token comment">// 初始化结果数组，注意数组定长，占位为0</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> 
  
  <span class="token comment">// 开始第一次遍历</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果栈的长度不为0，且不能维持递减数组的时候</span>
    <span class="token keyword">const</span> lastIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>lengt <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token constant">T</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token constant">T</span><span class="token punctuation">[</span>stack<span class="token punctuation">[</span>lastIndex<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将栈顶的元素取出</span>
      <span class="token keyword">const</span> top <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      
      <span class="token comment">// 计算二者之间的索引差差值</span>
      res<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> top
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 将当前索引值存入栈中</span>
    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>从上面的解法可以看出，比起暴力双层循环解法，我们在使用栈结构解决这个问题的时候，已经参与过对比的数字，不会被重复被对比，也就是说其实我们只把原数组遍历了一次，对于数组来讲我们的时间复杂度已经从 O(n^2)降到了O(n)，不得不说栈结构真的是个好东西啊！</p> <h2 id="数据结构-队列"><a href="#数据结构-队列" class="header-anchor">#</a> 数据结构-队列</h2> <h3 id="队列的概念"><a href="#队列的概念" class="header-anchor">#</a> 队列的概念</h3> <p>在认识了栈之后，我们可以来学习认识一下队列结构。队列顾名思义，就是把所有数据排队，按照【先进先出】的原则来进行出队入队。如果说栈结构是单方向进出，队列则是双向进出，这个特性要和栈结构区分开来。并且我们从队列多入口和多出口的特性，也可以预料到，队列能实现更加复杂的数据操作。</p> <h3 id="简易的队列方法"><a href="#简易的队列方法" class="header-anchor">#</a> 简易的队列方法</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">queue</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>

  <span class="token function">pop</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">push</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  
  <span class="token function">peek</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">.</span>length
  <span class="token punctuation">}</span>
  
  <span class="token function">empty</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>result<span class="token punctuation">.</span>length
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="初识队列结构"><a href="#初识队列结构" class="header-anchor">#</a> 初识队列结构</h3> <p>我们先来转换到队列的思想，先做一道小题开阔思路。如何把一个栈结构转变为队列结构呢？我们先来理一下思路。</p> <ol><li>栈是先进后出，而队列是先进先出，可以看出来队列算是栈的逆序操作</li> <li>说到逆序，那我们可以建立两个栈，把初始栈内的数据依次出栈存入到新的栈内，形成完全倒序栈，再依次从新的栈出栈即可</li> <li>但是有一种情况，是我们在新的栈未完全清空栈内数据的情况下，旧的栈又有了新的数据，这时我们可以在旧的栈数据全部出栈之后，在进行第二步，这样就能保证始终倒序的顺序。</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">MyQueue</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始化两个栈</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stack1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">MyQueue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">push</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 直接调度数组的 push 方法</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">MyQueue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">pop</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 假如 stack2 为空，需要将 stack1 的元素转移进来</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当 stack1 不为空时，出栈</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>length <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将 stack1 出栈的元素推入 stack2</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 为了达到逆序的目的，我们只从 stack2 里出栈元素</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">MyQueue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">peek</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当 stack1 不为空时，出栈</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 将 stack1 出栈的元素推入 stack2</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 缓存 stack2 的长度</span>
  <span class="token keyword">const</span> stack2Len <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">return</span> stack2Len <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">[</span>stack2Len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token class-name">MyQueue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">empty</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 若 stack1 和 stack2 均为空，那么队列空</span>
  <span class="token keyword">return</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h3 id="队列的进阶-双端队列"><a href="#队列的进阶-双端队列" class="header-anchor">#</a> 队列的进阶-双端队列</h3> <p>前面说过，队列可以双向进出。那么<strong>队列也可以允许在同一端进行插入和删除</strong>，对于编程而言，最常见的载体是既允许使用 pop、push 同时又允许使用 shift、unshift 的数组。这种队列我被称为<strong>双端队列</strong>。由双端队列衍生出的题目可谓是五花八门，也是算法中备受推崇的一个热点命题。</p> <p>那么简单介绍结束之后，我们来学习一下双端队列特征和使用</p> <p><strong>滑动窗口问题</strong></p> <p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
k <span class="token operator">=</span> <span class="token number">3</span>
<span class="token comment">// 输出 [3,3,5,5,6,7]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>解法一：快慢双指针法</strong></p> <p>算是简单回顾一下之前的方法，我们先用一个“淳朴”的方法先来解决一下，打开思路。</p> <ol><li>用快慢双指针先选定区间范围，形成一个“窗口”，逐渐移动</li> <li>在“窗口”范围内，找出最大值，并记录下来</li></ol> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">maxSlidingWindow</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 声明结果数组和最大长度</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length
	
  <span class="token comment">// 确定快慢指针的位置范围</span>
  <span class="token keyword">let</span> l <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">let</span> r <span class="token operator">=</span> k <span class="token operator">-</span> <span class="token number">1</span>
	
  <span class="token comment">// 遍历数组</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span> r <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
		
    <span class="token comment">// 将窗口内的数字存入</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
		
    <span class="token comment">// 找出窗口内最大值</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span>
		
    <span class="token comment">// 窗口移动</span>
    l<span class="token operator">++</span>
    r<span class="token operator">++</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>这个解法简单暴力，性能也还凑活，不用担心超时，就算是当做算法题的解法，也是完全ok的。</p> <p>但是这个解法并不是很优质的解法，因为他不可避免的多次进行了循环，那么我们就要深入研究一下更加优质的解法了。</p> <p><strong>解法二：双端队列法</strong></p> <p>打开思路之后，我们就有请我们本节的主角，双端队列登场，我们看一下如何使用双端队列解决问题。</p> <p>我们先来想一下上一个解法的缺陷，我们每次滑动窗口之后，都不可避免的要把窗口内的所有数组进行遍历、排序、比较，最后得出我们想要的结果，这样就造成了每次滑动窗口都要进行重复的遍历。可能窗口滑动之后，窗口内的数据最大值没有变化，但我们依然需要进行一系列步骤来找出最大值。</p> <p>既然我们找出缺陷所在，我们可以试想一下，我们可不可以在窗口滑动的时候只根据元素的变化更新最大值，这样我们可以直接取出最大值，提高性能！想到这点，那我们已经成功不远了！我们可以维护一个<strong>递减趋势</strong>的双端队列，下面来理一下思路。</p> <ol><li>我们先把遍历到的每一个元素推入队列中</li> <li>在推入元素之前，和队尾元素进行比较。如果当前元素小于队尾元素，则正常入队。如果当前元素大于队尾元素，那么我们的递减趋势被打破，从队尾开始将小于当前元素的元素依次出列(由于是双端队列，我们从队尾出队完全没问题)，此时队头的数字永远保持最大值。</li> <li>当遍历到的元素达到k的时候，意味着我们第一个窗口最大值已经产生了，这时取出队头的元素，把他push到结果数组中</li> <li>继续遍历原数组，在每走一步的时候，重复上面几步，维护递减趋势的双端队列，填充结果数组</li></ol> <p>下面我们来实现以下</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">maxSlidingQequeWindow</span> <span class="token punctuation">(</span><span class="token parameter">nums<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 原数组长度</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length
  <span class="token comment">// 结果数组</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token comment">// 双端队列数组</span>
  <span class="token keyword">const</span> deque <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 要点：构造递减队列</span>
    <span class="token comment">// 当队尾元素小于当前元素时，把前一个索引值出列，直到队尾元素大于等于当前元素</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>deque<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>deque<span class="token punctuation">[</span>deque<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      deque<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 入队当前元素索引（注意是索引）</span>
    deque<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    
    <span class="token comment">// 每次都需要剔除超出滑动窗口范围的元素</span>
    <span class="token comment">// i - k 是当前滑动窗口的最小索引值</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>deque<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> deque<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> i <span class="token operator">-</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      deque<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 因为队列是递减队列，所以只需取第一个数字即为最大的数，但是只有在被遍历的元素个数大于 k 的时候，才更新结果数组，即i&gt;=k-1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>deque<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>使用双端队列法，我们成功避免了内部对滑动窗口多次遍历、排序的问题。从上面的例子中，我们可以总结一下可以使用双端队列法类型的特点：队列的<strong>递减性</strong>以及<strong>有效性</strong>。</p> <h2 id="算法思想-dfs与bfs"><a href="#算法思想-dfs与bfs" class="header-anchor">#</a> 算法思想-DFS与BFS</h2> <p>说起算法，DFS（深度优先搜索）和BFS（广度优先搜索）是我们必须接触的一环，注意用词，是【必须】哦！因为他属于算法的基础思想。我们下面开始算法学习时候，先来补补课，认识一下这两个大兄弟。</p> <h3 id="初识dfs-深度优先搜索"><a href="#初识dfs-深度优先搜索" class="header-anchor">#</a> 初识DFS（深度优先搜索）</h3> <p>相信我们都玩儿过迷宫游戏，我们在走迷宫的时候，不论怎么选分支路线，都会走到底，如果是死路，才会返回之前的节点在进行探索。这种方式可以理解为使用了深度优先搜索的方式。</p> <p>那么从迷宫游戏中我们可以简单地先来总结一下深度优先搜索的核心原则，那就是<strong>一条路走到底，在没有走到底之前，不会回头选择其他路线，这样以深度为优先的搜索方式，就是深度优先搜索</strong>。</p> <h3 id="初识bfs-广度优先搜索"><a href="#初识bfs-广度优先搜索" class="header-anchor">#</a> 初识BFS（广度优先搜索）</h3> <p>同样是迷宫游戏，我们可以换一种走法，我们每走到一个岔口的时候，都先总结一下他有几个分支几条路。一层一层的往下走，而不是一条路走到底。这种方式可以理解为使用了广度优先搜索的方式。</p> <p>我们来简单总结一下广度优先搜索的核心原则，那就是<strong>分析每层有几个子节点，先把每一层的子节点全部遍历之后，再去走下一层，直到遍历结束为止，这样以广度为优先的搜索方式，就是广度优先搜索</strong>。</p> <h2 id="算法思想-递归与回溯-剪枝-思想"><a href="#算法思想-递归与回溯-剪枝-思想" class="header-anchor">#</a> 算法思想-递归与回溯(剪枝)思想</h2> <p>认识完DFS与BFS，下面我们真正的接触一下算法思想，其实算法离我们并不远。在日常项目中就会运用到算法思想，比如<strong>递归</strong>。这个对我们而言是比较熟悉的一种思想，在我们进行不确定深度层级的遍历的时候，总能用到它。今天我们也不长篇大论的来讨论所谓的【思想】，这个对于我们来说用处没那么大，个人认为算法这个东西，不是用来吹水，显得自己逼格够高的一种资本，而是希望能够切切实实帮助我们解决问题的，所以我们还是通过解题来慢慢的摸索他们的本质。</p> <h3 id="递归套路的第一个碰面"><a href="#递归套路的第一个碰面" class="header-anchor">#</a> 递归套路的第一个碰面</h3> <p>我们先来做leetcode淘来的一道【组合问题】的经典题型，<strong>数组全排列问题</strong>。虽然这道题算easy难度，但是真的很适合入门练手，大家也可以细品一下这道题。</p> <blockquote><p>题目描述：给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p></blockquote> <blockquote><p>示例：<br>
输入: [1,2,3]
输出: [
[1,2,3],
[1,3,2],
[2,1,3],
[2,3,1],
[3,1,2],
[3,2,1]
]</p></blockquote> <p>这个题其实就是我们上学时候的排列组合题，但是计算机没有公式，需要我们<strong>穷举</strong>出所有的排列可能性。注意到我刚才说的【穷举】哦，这个其实就是解决组合问题的关键字。</p> <p>说道【穷举】我们第一个反应应该想到DFS(深度优先搜索)就没错啦，DFS的核心是什么呢？就是递归！</p> <p>那么下面不管大家是新手，还是老手，都一起想想怎么完成这个递归！</p> <p>就拿上面的[1, 2, 3]来举例，我们怎么进行穷举呢？</p> <ol><li>第一步有三种选择1，2，3，假设我们拿到了1。</li> <li>第二步的时候他有两种选择，2或者3，假设我们拿到了2。</li> <li>第三步根据第二步的选择，只剩下一种选择，而能选的数字只剩下了3。</li></ol> <p>所以我们从这里看出，可能性一共有3✖️2✖️1=6。但可惜的是，我们是要求他们的组合，那么我们如何根据上面的穷举来进行递归呢？我们再来分析一下。</p> <ol><li>我们可以把每一步想成一个坑位，数组的length即是有多少个坑位待填充。</li> <li>遍历数组，让每一个数字都可以成为第一个坑位。</li> <li>在每次循环时候，走完了第一个坑位，调用当前方法进行递归，走到下一个坑位，那么什么时候算本轮次递归结束呢？那当然是length等于数组长度，即所有坑位被填满的时候。</li> <li>每轮次递归结束后，将数组push到结果数组中，循环结束，我们就得到了完全排列的数组。</li></ol> <p>下面我们来用代码实现一下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">permute</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 坑位的长度</span>
  <span class="token keyword">const</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span>length
  
  <span class="token comment">// 当前轮次递归，进行排列的数组内容</span>
  <span class="token keyword">const</span> cur <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  
  <span class="token comment">// 记录本轮次已经用过的数字 避免使用重复数字</span>
  <span class="token keyword">const</span> visited <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 所有存在的排列顺序的结果数组</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  
  <span class="token comment">// 深度遍历方法 接收排列的索引值 即我们一直在说的坑位</span>
  <span class="token keyword">function</span> <span class="token function">dfs</span> <span class="token punctuation">(</span><span class="token parameter">nth</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前正在排列的一个数组所有坑位都被占满的时候 返回排列好的数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nth <span class="token operator">===</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 在当前第nth个坑位中，递归遍历所有的数字，穷举排列可能</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> n <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
      <span class="token comment">// 如果当前数字没被使用过，则放入当前排列的数组中</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 放入当前排列的数组中</span>
        cur<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>

        <span class="token comment">// 打上已经用过的标记</span>
        visited<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>

        <span class="token comment">// 走到下一个坑位继续去深度遍历其他的值</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>nth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

        <span class="token comment">// 遍历结束后 让出当前数组中的坑位</span>
        cur<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment">// 释放当前的标记</span>
        visited<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token comment">// 从第一个坑位开始遍历</span>
  <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br></div></div><p>虽然代码行数不多，并且都有注释，相信第一次接触的同学们可能还是一脸懵，个人认为这道题不理解的话可以多花点时间看看，千万别因为是一道easy难度的题就小看了他，因为它包括了最核心的dfs思想，以及递归式的核心概念<strong>重复</strong>和<strong>边界</strong>。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">4/14/2021, 6:33:36 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/webProject/" class="prev">
        服务端部署
      </a></span> <span class="next"><a href="/article/">
        个人拓展文章
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.18f5c49f.js" defer></script><script src="/assets/js/2.3a20e52e.js" defer></script><script src="/assets/js/8.ee7f20e5.js" defer></script>
  </body>
</html>
